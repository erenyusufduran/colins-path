# SQL

| <font size="4px">**Contents**</font>                             |
| :--------------------------------------------------------------- |
| 1 - [***Advanced SQL Commands***](#commands)                     |
| 2 - [***Primary Keys and Foreign Keys***](#keys)                 |
| 3 - [***Constraints***](#constraints)                            |
| 4 - [***CREATE Table***](#createTable)                           |
| 5 - [***INSERT Table***](#insertTable)                           |
| 6 - [***UPDATE Table***](#updateTable)                           |
| 7 - [***DELETE Table***](#deleteTable)                           |
| 8 - [***ALTER Table***](#alterTable)                             |
| 9 - [***DROP Table***](#dropTable)                               |
| 10 - [***CHECK Constraints***](#check)                           |
| 11 - [***Conditional Expressions and Procedures***](#procedures) |
| 11.1 - [*CASE*](#case)                                           |
| 11.2 - [*COALESCE*](#coalesce)                                   |
| 11.3 - [*CAST*](#cast)                                           |
| 11.4 - [*NULLIF*](#nullIf)                                       |

## <a id="procedures">**Conditional Expressions and Procedures**</a>

## <a id="check">**CHECK Constraints**</a>

## <a id="commands">***Advenced SQL Commands***</a>

### **Timestamps and Extract**

- **TIME** - Contains only time
- **DATE** - Contains only date
- **TIMESTAMP** - Contains date and time
- **TIMESTAMPTZ** - Contains date, time and timezone

## <a id="keys">***Primary Keys and Foreign Keys***</a>

A primary key is a column or a group of columns used to identify a row uniquely in a table. Primary keys are also important since they allow us to easily discern what columns should be used for joining tables together.

A foreign key is a field or group of fields in a table that uniquely identifies a row in another table. A foreign key is defined in a table that references to the **primary key** of the other table.

The table that contains the foreign key is called refencing table or child table. The table to which the foreign key references is called referenced table or parent table.

When creating tables and defining columns, we can use constraints to define columns as being a primary key, or attaching a foreign key relationship to another table.

## <a id="constraints">**Constraints**</a>

- Contraints are the rules enforced on data columns on table.
- These are used to prevent invalid data from being entered into the database.
- This ensures the the accuracy and reliability of the data in the database.
  - **Column Constraints:** Constraints the data in a column to adhere to certain conditions.
  - **Table Constraints:** Applied to the entire table rather than to an individual column.

Most common contraints used; **NOT NULL**, **UNIQUE**, **PRIMARY KEY**, **FOREIGN KEY**, **CHECK**, **EXCLUSION**

## <a id="createTable">**CREATE Table**</a>

- **SERIAL** keyword:
  - In postgreSQL, a sequence is a special kind of database object that generates a sequence of integers.
  - A sequence is often used as the primary key column in a table.
  - It will create a sequence object and set the next value generated by the sequence as the default value for the column.
  - This is perfect for a primary key, because it logs unique integer entries for you automatically upon insertion.

```sql
CREATE TABLE account(
	user_id SERIAL PRIMARY KEY,
	username VARCHAR(30) UNIQUE NOT NULL,
	password VARCHAR(50) NOT NULL,
	email VARCHAR(100) UNIQUE NOT NULL,
	created_on TIMESTAMP NOT NULL,
	last_login TIMESTAMP
) -- This can be executed one time. Later on we will learn ALTERs.

CREATE TABLE job(
	job_id SERIAL PRIMARY KEY,
	job_name VARCHAR(150) UNIQUE NOT NULL
)
```

## <a id="insertTable">**INSERT Table**</a>

SERIAL columns do not need to be provided a value.

```sql
INSERT INTO account(username, password, email, created_on) 
VALUES
('Eren', 'password', 'erenydurann@gmail.com', CURRENT_TIMESTAMP)

INSERT INTO job(job_name)
VALUES
('Astronaut')

INSERT INTO job(job_name)
VALUES
('Astronaut')
```

## <a id="updateTable">**UPDATE Table**</a>

```sql
UPDATE account
SET last_login = CURRENT_TIMESTAMP

UPDATE account
SET last_login = created_on

UPDATE account_job
SET hire_date = account.created_on
FROM account
WHERE account_job.user_id = account.user_id

UPDATE account
SET last_login = CURRENT_TIMESTAMP
RETURNING email

UPDATE account
SET last_login = CURRENT_TIMESTAMP
RETURNING email, created_on, last_login
```

## <a id="deleteTable">**DELETE Table**</a>

```sql
DELETE FROM job WHERE job_name = 'President'
```

## <a id="alterTable">**ALTER Table**</a>

The `ALTER` clause allows for changes to an existing table structure, such as:
- Adding, dropping or renaming columns
- Changing a column's data type
- Set *DEFAULT* values for a column
- ADD *CHECK* constraints
- Rename table

```sql
CREATE TABLE information(
	info_id SERIAL PRIMARY KEY,
	title VARCHAR(100) NOT NULL,
	person VARCHAR(50) NOT NULL UNIQUE
)

ALTER TABLE information
RENAME TO new_info

ALTER TABLE new_info
RENAME COLUMN person TO people

ALTER TABLE new_info
ALTER COLUMN people DROP NOT NULL
```

## <a id="dropTable">**DROP Table**</a>

`DROP` allows for the complete removal of a column in a table.

```sql
ALTER TABLE new_info
DROP COLUMN IF EXISTS people
```

## <a id="check">**CHECK Constraints**</a>

The `CHECK` constraints allows us to create more customized constraints that adhere to a certain condition. Such as making sure all inserted integer values fall below a certain threshold.	

```sql
CREATE TABLE employees(
	emp_id SERIAL PRIMARY KEY,
	first_name VARCHAR(50) NOT NULL,
	last_name VARCHAR(50) NOT NULL,
	birthdate DATE CHECK (birthdate > '1900-01-01'),
	hire_date DATE CHECK (hire_date > birthdate),
	salary INTEGER CHECK (salary > 0)
)

INSERT INTO employees(first_name, last_name, birthdate, hire_date, salary)
VALUES
('Eren', 'Duran', '1920-11-03', '2010-01-11', 100)
```

## <a id="procedures">**Conditional Expressions and Procedures**</a>

These expressions and functions will allow us to add logic to our commands and workflows in SQL.

### <a id="case">**CASE**</a>

We can use the **CASE** statement to only execute SQL code when certain conditions are met. This is very similar to `IF/ELSE` statements in programming languages.

The **CASE** expression syntax first evaluates an expression then compares the result with each value in the `WHEN` clauses sequentially.

```sql
SELECT customer_id,
CASE 
	WHEN (customer_id < 100) THEN 'Premium'
	WHEN (customer_id BETWEEN 100 AND 200) THEN 'Plus'
	ELSE 'Normal'
END AS customer_class
FROM customer

SELECT customer_id,
CASE customer_id
	WHEN 2 THEN 'Winner'
	WHEN 5 THEN 'Second Place'
	ELSE 'Normal'
END AS raffle_results
FROM customer

SELECT
SUM(CASE rental_rate
	WHEN 0.99 THEN 1
	ELSE 0
END) AS number_of_bargains,
SUM(CASE rental_rate
   	WHEN 2.99 THEN 1
   	ELSE 0
END) AS regular,
SUM(CASE rental_rate
   	WHEN 4.99 THEN 1
   	ELSE 0
END) AS premium
FROM film

SELECT
SUM(
CASE rating
	WHEN 'R' THEN 1 ELSE 0
END) AS r,
SUM(
CASE rating
	WHEN 'PG' THEN 1 ELSE 0
END) AS pg,
SUM(
CASE rating
	WHEN 'PG-13' THEN 1 ELSE 0
END) AS pg13
FROM film
```

### <a id="coalesce">**COALESCE**</a>

THE **COALESCE** function becomes useful when querying a table that contains `null` values and substituting it with another value.

Keep the COLESCE function in mind in case you encounter a table with null values that you want to perform operations on!

### <a id="cast">**CAST**</a>

The **CAST** operator let's you convert from one data type into another.

- Keep in mind not every instance of a data type can be CAST to another data type, it must be reasonable to convert the data, *for example '5' to an integer will work, 'five' to an integer will not*.
- Keep in mind you can then use this in a `SELECT` query with a column name instead of a single instance
  - SELECT CAST(date AS TIMESTAMP) from table

```sql
SELECT CAST('5' AS INTEGER) AS new_int

SELECT CAST(inventory_id AS VARCHAR) FROM rental

SELECT CHAR_LENGTH(CAST(inventory_id AS VARCHAR)) FROM rental
```